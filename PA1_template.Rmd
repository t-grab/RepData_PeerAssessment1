---
title: 'Reproducible Research: Peer Assessment 1'
output:
  html_document:
    keep_md: yes
  pdf_document: default
---

```{r, echo=FALSE, results='hide'}
library(knitr)
library(ggplot2)
opts_chunk$set(echo=TRUE, results='hold', cache=FALSE)
opts_chunk$set(digits=7)
Sys.setlocale("LC_TIME", "English")
```

In the following report I...

I expect the data to be present on the computer in a zip file as described in...

## Loading and preprocessing the data

The process of loading and preprocessing the data is...

```{r}
unzip('activity.zip')
data <- read.csv('activity.csv')
data$date <- as.Date(data$date)
```

## What is mean total number of steps taken per day?

To answer this question, I first aggregate...

```{r}
stepsPerDay <- aggregate(steps ~ date, data, sum, na.action = na.omit)
stepsPerDayPlot <- ggplot(stepsPerDay, aes(x=steps)) +
    geom_histogram(binwidth=(max(stepsPerDay$steps)-min(stepsPerDay$steps)) / 25) +
    labs(title='Mean total number of steps per day',
         x='Number of steps',
         y='Frequency') 
stepsPerDayPlot
```

Based on the data which was created by aggregation in the last section, I calculated
the mean and the median number of steps taken per day as follows:

```{r}
stepsMean <- mean(stepsPerDay$steps, na.rm=TRUE)
stepsMedian <- median(stepsPerDay$steps, na.rm=TRUE)
```

Due to these calculations the mean number of steps taken each day is around **`r sprintf('%.2f', stepsMean)`**, the
median is at **`r stepsMedian`**.

## What is the average daily activity pattern?

At first...

```{r}
stepsPerInterval <- aggregate(steps ~ interval, data, mean, na.action = na.omit)
ggplot(stepsPerInterval, aes(x=interval, y=steps)) +
    geom_line(size=0.725) +
    labs(title='Average daily activity pattern',
         x='Interval',
         y='Number of steps')
```

A glance at the figure above suggests that the 5-minute interval with the maximum 
number of steps, averaged across all days, is the peek between 750 and 1000.
The following code based on the aggregated data from the last section computes that
interval.

```{r, results='markup'}
stepsMax <- stepsPerInterval[which.max(stepsPerInterval$steps),]
print(stepsMax)
```

Therefore, it is the `r stepsMax$interval`^th^ interval which contains with about
`r sprintf('%.2f',stepsMax$steps)` (on average) the maximum number of steps.

## Imputing missing values

A lot of observations in the dataset are incomplete, which means that value for 
the steps is missing. I calculated the amount of those incomplete observations as
follows:

```{r}
table(is.na(data$steps))
```

Obviously, there are `r sum(is.na(data$steps))` observations, where there is no
value present for steps, while `r sum(!is.na(data$steps))` do have one. Thus,
`r sprintf('%.2f',(sum(is.na(data$steps)) / length(data$steps))*100)`% 
of the observations do not contain any value for steps. 

The amount is not too high, though it still may introduce some bias into some
calculations as stated in the assessment instructions. To overcome that problem
I developed a strategy for imputing the missing values.

I therefore considered two different options:

1. Replace a missing value with the mean or the median of the day.
2. Replace a missing value with the mean or the median of the specific interval.

To decide between one of those strategies I made a little experiment. I looked at
the distribution of the missing values.

Looking at the missing values, I made the following discovery: Every interval contains
the exact same amount of missing values.

```{r}
NAs <- tapply(data$steps, data$interval, function(dat) {sum(is.na(dat))})
summary(NAs)
```

This suggests that there are 8 complete days where there are no values at all.
To proof this, I made the following attempt:

1. Create a list with vectors for all intervals containing a
logical value if steps is missing for that interval on a day or not
2. Comparing the days where intervals have missing values by using the logical
OR-operator on the whole list of vectors. The resulting logical vector identifies
days where at least one interval contains a missing value.
3. Summing up the days with missing values.

```{r}
isNA <- tapply(data$steps, data$interval, is.na)
result <- rep(FALSE, length(isNA[[1]]))

for(i in seq_along(isNA)) {
    result <- result | isNA[[i]]
}

sum(result)
```

The result is `r sum(result)`. When every interval has exactly 8 missing values
and there are just `r sum(result)` days that contain missing values at all, there
have to be exactly `r sum(result)` days that have missing values for every interval.
The following calculation shows this even better. Every day is devided into 5-minute
intervals, so there should be eight days that have 288 NA values for steps:

```{r}
tapply(data$steps, data$date, function(dat) {sum(is.na(dat))})
```

As the table shows that is true. There are eight days that do not have any values
at all.

Thus, the first strategy does not seem to be promising and I decided to use the
second one using the mean to impute the values.

```{r}
means <- tapply(data$steps, data$interval, mean, na.rm=T, simplify=F)
imputed.data <- data
imputed.data$steps <- mapply(function(step, interval) {
    if(is.na(step))
        return (means[[as.character(interval)]])
    else
        return (step)
}, imputed.data$steps, imputed.data$interval)
```

To further improve the strategy, one could look at the dates of the days whose
values are missing. If they belong to just certain parts of the week (e.g. weekends),
it would improve the imputing by using only the values of the days that belong to
the same part of the week.

Having the dataset with imputed values, it is of interest to reanswer the first
question asked to compare the results and to figure out, whether the missing values
led to any bias or not.

```{r}
imputed.stepsPerDay <- aggregate(steps ~ date, imputed.data, sum, na.action = na.omit)
imputed.plot <- ggplot(imputed.stepsPerDay, aes(x=steps)) +
    geom_histogram(binwidth=(max(imputed.stepsPerDay$steps)-min(imputed.stepsPerDay$steps)) / 25) +
    labs(title='Mean total number of steps per day (imputed missing values)',
         x='Number of steps',
         y='Frequency') 
imputed.plot
```

Median and mean are computed as before.

```{r}
imputed.stepsMean <- mean(imputed.stepsPerDay$steps, na.rm=TRUE)
imputed.stepsMedian <- median(imputed.stepsPerDay$steps, na.rm=TRUE)
```

With the imputed values the mean is around **`r sprintf('%.2f',imputed.stepsMean)`**
and the median is around **`r sprintf('%.2f',imputed.stepsMedian)`**.

### Comparison

To compare the both I first create a plot showing visualizing the imputed data
as well as the original data.

```{r}
stepsPerDay <- cbind(stepsPerDay, rep(FALSE, length(stepsPerDay$steps)))
imputed.stepsPerDay <- cbind(imputed.stepsPerDay, rep(TRUE, length(imputed.stepsPerDay$steps)))
colnames(stepsPerDay)[3] <- "Imputed"
colnames(imputed.stepsPerDay)[3] <- "Imputed"

comparison.stepsPerDay <- rbind(stepsPerDay, imputed.stepsPerDay)

ggplot(comparison.stepsPerDay, aes(x=steps)) +
    geom_histogram(binwidth=(max(comparison.stepsPerDay$steps)-min(comparison.stepsPerDay$steps)) / 25,
                   aes(fill=Imputed), position="dodge") +
    labs(title='Mean total number of steps per day',
         x='Number of steps',
         y='Frequency')
```

As one can see imputing the missing values has not affected most parts of the distribution
at all, however, the center of the distribution, the peek, has doubled. This is due to
the fact that before imputing the missing values, there were exactly eight complete days
that lacked values. By using the interval mean to impute the missing values, the overall
number of steps for those days was naturally identical and very close to the mean and
the median of the other days. Thus, imputing the missing values has not changed very much.
The mean stayed with around `r sprintf('%.2f',imputed.stepsMean)` the same. The median rose
slightly from `r stepsMedian` to `r sprintf('%.2f',imputed.stepsMedian)`, but not significantly.

To sum up, on can say that this particular strategy for imputing missing values has
no impact on the estimates of the total daily number of steps.

## Are there differences in activity patterns between weekdays and weekends?

```{r}
imputed.data$day <- sapply(imputed.data$date, function(date) {
    if (weekdays(date) %in% c("Saturday", "Sunday"))
        "Weekend"
    else
        "Weekday"
})

imputed.stepsPerInterval <- aggregate(steps ~ interval + day, imputed.data, mean)

ggplot(imputed.stepsPerInterval, aes(interval, steps)) +
    geom_line(aes(color=day)) +
    labs(title="Activity patterns on weekdays and weekends",
         x="Interval",
         y="Number of steps")
```